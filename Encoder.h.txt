#include "C12832.h" // Include the C12832 LCD display library header file.

#define WHEEL_RADIUS 0.040 // Define the radius of the wheel in meters.

// Initialize the LCD display by specifying the pin connections.
C12832 lcd(D11, D13, D12, D7, D10); // LCD display object. Pin connections are PA_7, PA_5, PA_6, PA_8, and PB_6 respectively.

class Encoder {
    protected:
        QEI* Encoder_R; // Pointer to a QEI object representing the right wheel encoder.
        QEI* Encoder_L; // Pointer to a QEI object representing the left wheel encoder.
        unsigned long count_R, count_L, oldR, oldL, pulses_R, pulses_L; // Variables to store encoder counts and pulses.
        Timer t_R, t_L;  // Timers to measure intervals for speed calculations.
        float dt_R, dt_L, speed_R, speed_L, trans_Speed, rot_Speed; // Variables for delta times, wheel speeds, and velocities.

    public:
        // Constructor initializes encoder objects and resets counts.
        Encoder(QEI* A, QEI* B): Encoder_R(A), Encoder_L(B) {
            Encoder_L->reset(); // Reset the left wheel encoder count.
            Encoder_R->reset(); // Reset the right wheel encoder count.
            count_R = count_L = 0; // Initialize counts to 0.
        }

        // Calculate and return the speed of the right wheel.
        float GetSpeedR(void) {
            oldR = count_R; // Store the old count.
            count_R = abs(Encoder_R->getPulses()); // Get the absolute value of the current pulse count.
            dt_R = t_R.read_us(); // Read the elapsed time in microseconds since the timer was last reset.

            // Calculate the speed based on the change in pulse count and the elapsed time.
            if (Encoder_R->getPulses() < 0) {
                speed_R = -1 * (((count_R - oldR) / 1024.0) / (dt_R / 1000000.0)) * (2.0 * PI * WHEEL_RADIUS);
            } else if (Encoder_R->getPulses() > 0) {
                speed_R = (((count_R - oldR) / 1024.0) / (dt_R / 1000000.0)) * (2.0 * PI * WHEEL_RADIUS);
            }

            t_R.reset(); // Reset the timer.
            t_R.start(); // Start the timer for the next measurement.
            return speed_R; // Return the calculated speed.
        }

        // Calculate and return the speed of the left wheel (similar to GetSpeedR).
        float GetSpeedL(void) {
            oldL = count_L;
            count_L = abs(Encoder_L->getPulses());
            dt_L = t_L.read_us();

            if (Encoder_L->getPulses() < 0) {
                speed_L = -1 * (((count_L - oldL) / 1024.0) / (dt_L / 1000000.0)) * (2.0 * PI * WHEEL_RADIUS);
            } else if (Encoder_L->getPulses() > 0) {
                speed_L = (((count_L - oldL) / 1024.0) / (dt_L / 1000000.0)) * (2.0 * PI * WHEEL_RADIUS);
            }

            t_L.reset();
            t_L.start();
            return speed_L;
        }

        // Calculate and display the translational velocity (average of the two wheel speeds).
        float GetTransVelocity(void) {
            trans_Speed = (GetSpeedR() + GetSpeedL()) / 2.0; // Average of right and left wheel speeds.
            lcd.locate(0, 3); // Set cursor position on the LCD.
            lcd.printf("Translational: %f", trans_Speed); // Display translational speed on the LCD.
            return trans_Speed; // Return the calculated translational speed.
        }

        // Calculate and display the angular velocity based on the translational speed and wheel radius.
        float GetAngularVelocity(void) {
            rot_Speed = (trans_Speed) / WHEEL_RADIUS; // Angular speed calculation.
            lcd.locate(0, 14); // Set cursor position on the LCD.
            lcd.printf("Rotational: %f", rot_Speed); // Display rotational speed on the LCD.
            return rot_Speed; // Return the calculated rotational speed.
        }

        // Get the pulse count for the left wheel encoder.
        long GetPulsesL(void) {
            return (Encoder_L->getPulses());
        }

        // Get the pulse count for the right wheel encoder.
        long GetPulsesR(void) {
            return (Encoder_R->getPulses());
        }

        // Reset both wheel encoders.
        void Reset(void) {
            Encoder_R->reset();
            Encoder_L->reset();
        }
};
